package mwe
// https://scastie.scala-lang.org/EWXlRfJXTwergGIZXY2clg
import cats.Foldable
import cats.syntax.all._
// HeavyBool


import HeavyBool.{Reason, HTrue, HFalse, forallM, existsM}


sealed abstract class HeavyBool(val because:Reason) {
  override def toString:String = locally{
    val prefix:String = toBoolean.toString
    val reasoning:List[String] = for{ m <- because
                                      } yield locally{
      val listOfKeys = (for{(k,v)<- m} yield s"$k->$v").toList

      if (1 == listOfKeys.size)
        listOfKeys.head
      else
        listOfKeys.mkString("(",", ",")")
    }
    prefix + reasoning.mkString("[", "; ", "]")
  }

  val toBoolean: Boolean = {
    this match {
      case HeavyTrue(_) => true
      case HeavyFalse(_) => false
    }
  }

  // logical OR between to HeavyBool objects,
  // `that` is only evaluated if this is HeavyFalse.
  def ||(that: => HeavyBool):HeavyBool = {
    this match {
      case HeavyTrue(_) => this
      case HeavyFalse(_) => that
    }
  }


  // logical AND between to HeavyBool objects,
  // `that` is only evaluated if this is HeavyTrue
  def &&(that: => HeavyBool):HeavyBool = {
    this match {
      case HeavyTrue(_) => that
      case HeavyFalse(_) => this
    }
  }

  def unary_! : HeavyBool = {
    this match {
      case HeavyTrue(str) => HeavyFalse(str)
      case HeavyFalse(str) => HeavyTrue(str)
    }
  }

  // implies:   this ==> that
  def ==>(that: => HeavyBool): HeavyBool = {
    !this || that
  }

  // implied by:   this <== that
  def <==(that: => HeavyBool): HeavyBool = {
    this || !that
  }

  def ++(any: Map[String,Any]): HeavyBool = {
    this match {
      case HeavyTrue(because) => HeavyTrue(any :: because)
      case HeavyFalse(because) => HeavyFalse(any :: because)
    }
  }

  def +| (reason:String): HeavyBool = this ++ Map("reason" -> reason)

  def annotate(reason:String): HeavyBool = {
    this.conjTrue(Map{"success" -> reason}).conjFalse(Map("failure" -> reason))
  }

  def conjTrue(another: Map[String,Any]): HeavyBool = {
    this match {
      case HeavyTrue(_) => this ++ another
      case HeavyFalse(_) => this
    }
  }

  def conjFalse(another: Map[String,Any]): HeavyBool = {
    this match {
      case HeavyTrue(_) => this
      case HeavyFalse(_) => this ++ another
    }
  }
}


case class HeavyTrue(override val because: Reason) extends HeavyBool(because) {}

case class HeavyFalse(override val because: Reason) extends HeavyBool(because) {}

object HeavyBool {
  type Reason = List[Map[String, Any]]
  val HTrue = HeavyTrue(List())
  val HFalse = HeavyFalse(List())

  def apply(x:Boolean):HeavyBool = {
    if (x)
      HTrue
    else
      HFalse
  }

  def apply(test:Boolean, because:Reason):HeavyBool = {
    if (test)
      HeavyTrue(because)
    else
      HeavyFalse(because)
  }

  def heavyIf(cond:HeavyBool,
              consequent: => HeavyBool,
              alternative: => HeavyBool) = {
    if (cond.toBoolean)
      consequent
    else
      alternative
  }

  def forallM[T, C[_]](tag:String, items: C[T])( p: T => HeavyBool)(implicit ev: Foldable[C]): HeavyBool = {
    import cats._
    import cats.syntax.all._

    def folder(_hb:HeavyBool, item:T):Either[HeavyBool,HeavyBool] = {
      val hb = p(item)
      if (hb.toBoolean)
        Right(HTrue) // not yet finished
      else
        Left(hb ++ Map("witness" -> item,
                       "tag" -> tag)) // finished
    }

    items.foldM(HTrue:HeavyBool)(folder).merge
  }

  def existsM[T, C[_]](tag:String, items: C[T])(p: T => HeavyBool)(implicit ev: Foldable[C]): HeavyBool = {
    !(forallM[T,C](tag, items)(x => !(p(x)))(ev))
  }

  def assertM(a: HeavyBool):Unit = {
    a match {
      case HeavyTrue(_) => ()
      case HeavyFalse(str) => throw new java.lang.AssertionError(str)
    }
  }
  def main(argv:Array[String]):Unit = {}
}


// Magma


abstract class Magma[T,C[_]] {

  implicit var ev:Foldable[C] = implicitly[Foldable[C]]
  def gen()(implicit ev:Foldable[C]): C[T]

  def op(a: T, b: T): T

  def member(a: T): HeavyBool

  def equiv(a: T, b: T): HeavyBool = {
    if (a == b)
      HTrue
    else
      HFalse
  }.annotate("equivalent") ++ Map("a" -> a, "b" -> b)

  def isClosed(): HeavyBool = {
    forallM("a", gen()){ a:T =>
      forallM("b", gen()) { b: T =>
        member(op(a, b)) ++ Map("op(a,b)" -> op(a, b))
      }}}.annotate("closed")

  def isAssociative(): HeavyBool = {
    forallM("a", gen()) { a:T =>
      forallM("b", gen()) { b:T =>
        forallM("c", gen()) { c:T =>
          equiv(op(op(a, b), c),
                op(a, op(b, c)))
        }}}}.annotate("associative")

  def isAbelian(): HeavyBool = {
    forallM("a", gen()) { a:T =>
      forallM("b", gen()) { b: T =>
        equiv(op(a, b), op(b, a))
      }}}.annotate("commutative")

  def isIdentity(z: T): HeavyBool = {
    forallM("a", gen()) { a:T =>
      equiv(op(a, z), a) && equiv(op(z, a), a)
    }}.annotate("identity") ++ Map("z" -> z)

  def findIdentity(): Option[T] = {
    gen().find(z => isIdentity(z) match {
      case HeavyTrue(_) => true
      case _ => false
    })
  }

  def findInverse(z: T, a: T): Option[T] = {
    gen().find(b => (equiv(z, op(a, b)) && equiv(z, op(b, a))).toBoolean)
  }

  def findInverse(a: T): Option[T] = {
    findIdentity() match {
      case None => None
      case Some(z) => findInverse(z, a)
    }
  }

  def isInverter(z: T, invert: T => Option[T]): HeavyBool = {
    forallM("a", gen()) { a:T =>
      invert(a) match {
        case None => HFalse +| s"because $a has no inverse"
        case Some(b) =>
          member(b) &&
            equiv(z, op(a, b)) &&
            equiv(z, op(b, a))
      }}}.annotate("find inverter") ++ Map("z" -> z)

  def isSemiGroup(): HeavyBool = {
    (isClosed() && isAssociative())
  }.annotate("semigroup")

  def isMonoid(z: T): HeavyBool = {
    (isSemiGroup() && isIdentity(z))
  }.annotate("monoid")

  def isGroup(z: T, invert: T => Option[T]): HeavyBool = {
    (isMonoid(z) && isInverter(z, invert))
  }.annotate("group")
}

object Magma {

  import HeavyBool._

  // generate a lazy list from 0 to n inclusive
  def genFinite(n: Int): LazyList[Int] = {
    LazyList.from(0 to n)
  }

  def cayleyTable[T](elements: LazyList[T], op: (T, T) => T): String = {
    val header: String = "*|" ++ elements.map(x => s"$x").mkString(" ")
    val divider: String = "-+" ++ elements.map(x => "-").mkString("-")
    "\n" ++ header ++ "\n" ++ divider ++ "\n" ++ elements
      .map(x => elements.map(y => s"${op(x, y)}")
        .mkString(s"$x|", " ", ""))
      .mkString("\n")
  }



  def randomCayleyTable(n:Int):(Int,Int)=>Int = {
    import scala.util.Random
    // generate a function representing one possible addition table of a
    // magma of n elements, numbers 0 to n-1 with the restriction
    // that 0+z= 0 and z+0 = z
    val tbl = (for{row <- 1 to n-1
                   col <- 1 to n-1 }
    yield (row,col) -> Random.between(0,n)).toMap

    def add(a: Int, b: Int): Int = {
      if (a == 0)
        b
      else if (b == 0)
        a
      else tbl((a,b))
    }

    add
  }

  def randomCayleyTables(n:Int):LazyList[(Int,Int)=>Int] = {
    randomCayleyTable(n) #:: randomCayleyTables(n)
  }

  def allUnitalCayleyTables(n: Int): LazyList[(Int, Int) => Int] = {
    import scala.math.pow
    // generate a lazy sequence of length n^n * (n-1)^2 of functions
    // each representing one possible addition table of a
    // magma of n elements, numbers 0 to n-1 with the restriction
    // that 0+z= 0 and z+0 = z
    def recur(i: Int): LazyList[(Int, Int) => Int] = {
      def add(a: Int, b: Int): Int = {
        if (a == 0)
          b
        else if (b == 0)
          a
        else {
          // interpret i as a (n-1)x(n-1) digit number in base n, i.e., composed
          // of digits 0 ... (n-1)
          // arrange these digits into an (n-1) x (n-1) matrix, and return
          // the element at row a, column b.
          // i.e. the digit in position (1 based) (a-1)*(n-1)+(b-1)
          // we know that a>0 and b>0 because of the first two clauses
          // of the if/else-if.
          val pos = (a - 1) * (n - 1) + (b - 1)
          i / pow(n, pos).toInt % n
        }
      }

      if (i < 0)
        LazyList()
      else
        add _ #:: recur(i - 1)
    }
    // n ^ ((n-1)^2)
    // e.g., if n=8, we want to know how many 49 digit base 8 numbers exist?
    // i.e., 8^((8-1)*(8-1))
    // if n=2, how many 1 digit base 2 numbers = 1^2 = 2
    // if n=3, how many 4 digit base 3 numbers = 3^4 = 81
    // if n=4, how many 9 digit base 4 numbers = 4^9 = 262144
    recur(pow(n, (n - 1) * (n - 1)).toInt - 1)
  }

  def allCayleyTables(n: Int): LazyList[(Int, Int) => Int] = {
    import scala.math.pow

    def recur(i: Int): LazyList[(Int, Int) => Int] = {
      def add(a: Int, b: Int): Int = {
        // interpret i as a n x n  digit number in base n, i.e., composed
        // of digits 0 ... (n-1)
        // arrange these digits into an n x n matrix, and return
        // the element at row a, column b.
        // i.e. the digit in position (0 based) a*n+b
        val pos = a * n + b
        i / pow(n, pos).toInt % n
      }

      if (i < 0)
        LazyList()
      else
        add _ #:: recur(i - 1)
    }

    recur(pow(n, n*n).toInt - 1)
  }

  def countGroups(n:Int) = {
    val elements = genFinite(n-1)
    var groups = 0
    var abeliangroups = 0
    var monoids = 0
    var abelianmonoids = 0
    var semigroups = 0
    var abeliansemigroups = 0
    var tries = 0
    var abelians = 0
    // find n element monoids
    for {dyn_op <- allCayleyTables(n)
         dm = DynMagma(() => elements,
                       op1 = dyn_op,
                       member1 = (a: Int) => elements.contains(a)
                       )
         ab = dm.isAbelian()
         } {
      tries += 1
      if (ab.toBoolean)
        abelians += 1
      (dm.isGroup(0, (x:Int) => dm.findInverse(x)) match {
        case tf: HeavyFalse => tf // println(str)
        case tf: HeavyTrue =>
          groups += 1
          monoids += 1
          semigroups += 1
          if (ab.toBoolean) {
            abeliangroups += 1
            abelianmonoids += 1
            abeliansemigroups += 1
          }
          print("found"
                  + (if (ab.toBoolean) " Abelian" else "")
                  + s" group ${cayleyTable(elements, dyn_op)} ")
          tf ++ Map("reason" -> (s"found a group " + cayleyTable(elements, dyn_op)))
      }) ||
        (dm.isMonoid(0) match {
          case tf: HeavyFalse => tf //println(str)
          case tf: HeavyTrue =>
            monoids += 1
            semigroups += 1
            if (ab.toBoolean) {
              abelianmonoids += 1
              abeliansemigroups += 1
            }
            tf ++ Map("reason" -> ("found a monoid " + cayleyTable(elements, dyn_op)))
        }) ||
        (dm.isSemiGroup() match {
          case tf: HeavyFalse => tf //println(str)
          case tf: HeavyTrue =>
            semigroups += 1
            if (ab.toBoolean) {
              abeliansemigroups += 1
            }
            tf ++ Map("reason" -> ("found a semigroup " + cayleyTable(elements, dyn_op)))
        })
    }
    println(s"magmas: $tries   abelian=$abelians")
    println(s"semigroups: $semigroups   abelian=$abeliansemigroups")
    println(s"monoids: $monoids   abelian=$abelianmonoids")
    println(s"groups:  $groups   abelian=$abeliangroups")
  }

  def findGroupsM(n:Int) = {
    val elements = genFinite(n-1) // [0, 1, 2] size 3
    var groups = 0
    var tries = 0

    for { add <- allUnitalCayleyTables(n)
          _ = (tries += 1)
          dm = DynMagma(() => elements,
                        op1 = add,
                        member1 = (a: Int) => elements.contains(a)
                        )
          ig = dm.isGroup(0, x => dm.findInverse(x))
          if ig.toBoolean
          }  {
      val table = cayleyTable(elements, add)
      groups += 1
      println(s"found a group " + table + s": $ig")
    }
    println(s"groups:  $groups/$tries")
  }

  def isRing[T](gen: () => LazyList[T],
                member: T => HeavyBool,
                add: (T, T) => T, mult: (T, T) => T,
                invert: T => Option[T],
                one: T, zero: T): HeavyBool = {
    val ma = DynMagma[T](gen, add, x => member(x).toBoolean)
    val mb = DynMagma[T](gen, mult, x => member(x).toBoolean)
    ma.isGroup(zero, invert) &&
      ma.isAbelian() &&
      mb.isMonoid(one) &&
      forallM("a", gen()) { a =>
        forallM("b", gen()) { b =>
          forallM("c", gen()) { c =>
            // left distribute
            ma.equiv(mult(a, add(b, c)),
                     add(mult(a, b), mult(a, c)))
              .conjFalse(Map("reason" -> s"$a does not left-distribute across ($b+$c)")) &&
              // right distribute
              ma.equiv(mult(add(b,c),a),
                       add(mult(b,a),mult(c,a)))
                .conjFalse(Map("reason" -> s"$a does not right-distribute across ($b+$c)"))
          }}}}

  def isField[T](gen: () => LazyList[T],
                 member: T => HeavyBool,
                 add: (T, T) => T, mult: (T, T) => T,
                 add_invert: T => Option[T], mult_invert: T => Option[T],
                 one: T, zero: T): HeavyBool = {
    val ma = DynMagma[T](gen, add, x => member(x).toBoolean)
    lazy val mb = DynMagma[T](gen, mult, x => member(x).toBoolean)
    lazy val mz = DynMagma[T](non_zero_gen, mult, x => member(x).toBoolean)
    def non_zero_gen():LazyList[T] = {
      gen().filter(_ != zero)
    }
    !ma.equiv(one,zero) &&
      mb.isAbelian().conjFalse(Map("reason" -> "not Abelian")) &&
      isRing(gen, member,
             add, mult, add_invert,
             one, zero).conjFalse(Map("reason" -> s"not a ring")) &&
      mz.isInverter(one, mult_invert)
        .conjFalse(Map("reason" -> "invalid inversion"))
  }

  def main(argv: Array[String]): Unit = {

  }
}

// ModP


abstract class ModP(p: Int) extends Magma[Int, LazyList] {
  override def toString: String = s"ModP($p)"

  override def gen()(implicit ev: Foldable[LazyList]): LazyList[Int] = Magma.genFinite(p - 1)

  override def equiv(a: Int, b: Int): HeavyBool = {
    if (a == b)
      HTrue +| s"$a equiv $b"
    else
      HFalse +| s"$a not equiv $b"
  }.annotate(s"equiv mod $p")

  override def member(a: Int): HeavyBool = {
    if (a < 0)
      HFalse +| s"$a is not member because $a < 0"
    else if (a >= p)
      HFalse +| s"$a is not a member because $a >= $p"
    else
      HTrue +| s"0 <= $a < $p"
  }.annotate("member")
}

class AdditionModP(p: Int) extends ModP(p) {
  override def toString: String = s"AdditionModP($p)"

  override def op(a: Int, b: Int): Int = (a + b) % p

  def suggestInverse(a:Int):Option[Int] = {
    Some(0)
  }
}

class MultiplicationModP(p: Int) extends ModP(p) {
  override def toString: String = s"MultiplicationModP($p)"

  override def gen()(implicit ev:Foldable[LazyList]): LazyList[Int] = {
    super.gen()(ev).filter { a:Int => a != 0 }
  }

  override def member(a: Int): HeavyBool = {
    if (a <= 0)
      HFalse +| s"$a <= 0"
    else
      super.member(a)
  }.annotate("member")

  override def op(a: Int, b: Int): Int = (a * b) % p
}

// GaussianIntModP


class GaussianIntModP(p: Int) extends Magma[(Int,Int), LazyList] {
  override def toString: String = s"GaussianModP($p)"
  val zero = (0,0)
  val one = (1,0)

  def mod(a:Int):Int = {
    ((a % p) + p) % p
  }

  def mod2(a:Int, b:Int):(Int,Int) = {
    (mod(a), mod(b))
  }

  def add(a: (Int, Int), b: (Int, Int)): (Int, Int) = {
    val (x, y) = a
    val (u, v) = b
    mod2(x + u, y + v)
  }

  def subtract(a: (Int, Int), b: (Int, Int)): (Int, Int) = {
    val (x, y) = a
    val (u, v) = b
    mod2(x - u, y - v)
  }

  def mult(a: (Int, Int), b: (Int, Int)): (Int, Int) = {
    val (x, y) = a
    val (u, v) = b
    mod2(u*x - v*y, u*y  + v*x)
  }

  def mult_inv(ab:(Int,Int)):Option[(Int,Int)] = {
    // a+bi has inverse (a - bi)/(a^2 + b^2) in the
    //   case that a^2 + b^2 is non-zero (modulo p)
    val (a,b) = ab
    val denom = mod(a*a + b*b)
    if (denom == 0)
      None
    else
      (1 until p).find(z => mod(z*denom) == 1)
        .map(z => mod2(a*z, -b*z))
  }

  def op(a: (Int, Int), b: (Int, Int)): (Int, Int) = {
    add(a,b)
  }

  override def gen()(implicit ev:Foldable[LazyList]): LazyList[(Int,Int)] = {
    def loop(u:Int,v:Int):LazyList[(Int,Int)] = {
      if (u==p)
        LazyList.empty
      else if (v==p)
        loop(u+1,0)
      else
        (u,v) #:: loop(u,v+1)
    }
    loop(0,0)
  }

  override def equiv(a: (Int,Int), b: (Int,Int)): HeavyBool =
    if (a == b)
      HTrue ++ Map("reason" -> "a equiv b",
                   "a" -> a,
                   "b" -> b)

    else {
      HFalse ++ Map("reason" -> "a not equiv b",
                    "a" -> a,
                    "b" -> b)
    }

  override def member(a: (Int,Int)): HeavyBool = ({
    val (x,y) = a
    if (x < 0)
      HFalse +| s"$x < 0"
    else if (y < 0)
      HFalse +| s"$y < 0"
    else if (x >= p)
      HFalse +| s"$x >= $p"
    else if (y >= p)
      HFalse +| s"$y >= $p"
    else
      HTrue +| s"0 <= $x < $p and 0 <= $y < $p"
  } ++ Map("a" -> a)).annotate("member")
}

object testGaussianInt {
  def main(argv: Array[String]): Unit = {

    for {p <- (2 to 30).view
         m = new GaussianIntModP(p)
         f = Magma.isField(m.gen, m.member,
                           m.add, m.mult,
                           (a:(Int,Int)) => Some(m.subtract(m.zero, a)),
                           m.mult_inv,
                           m.one, m.zero
                           ).conjFalse(Map("reason" -> s"$m not a field")) &&
           HTrue +| s"$m is a field"
         } println(s"$p: $f")
  }
}

// DynMagma


case class DynMagma[T](gen1: () => LazyList[T],
                       op1: (T, T) => T,
                       member1: T => Boolean) extends Magma[T, LazyList] {
  override def toString: String = "dyn"
  def gen()(implicit ev: Foldable[LazyList]): LazyList[T] = gen1()

  def op(a: T, b: T): T = op1(a, b)

  def member(a: T): HeavyBool = member1(a) match {
    case true => HTrue ++ Map("reason" -> "a is a member",
                              "a" -> a)

    case false => HFalse ++ Map("reason" -> "a is not a member",
                                "a" -> a)
  }
}


object Relations {
  def isReflexive[T](gen:LazyList[T], rel:(T,T)=>Boolean) = {
    forallM("x", gen){(x:T) =>
      forallM("y", gen){(y:T) => HeavyBool(rel(x,y))}}
      .annotate("reflexive")
  }

  def isSymmetric[T](gen:LazyList[T], rel:(T,T)=>Boolean) = {
    def hrel(a: T, b: T) = HeavyBool(rel(a, b))

    forallM("x", gen) { (x: T) =>
      forallM("y", gen) { (y: T) => hrel(x, y) ==> hrel(y, x) }
    }.annotate("symmetric")
  }

  def isTransitive[T](gen:LazyList[T], rel:(T,T)=>Boolean):HeavyBool = {
    def hrel(a:T, b:T) = HeavyBool(rel(a,b))
    forallM("x", gen){ (x:T) =>
      forallM("y", gen){ (y:T) => {
        if (rel(x, y))
          forallM("z", gen) { (z: T) =>
            hrel(y, z) ==> hrel(x, z)
          }
        else
          HTrue
      }}}.annotate("transitive")
  }

  def isEquivalence[T](gen:LazyList[T], rel:(T,T)=>Boolean):HeavyBool = {
    isSymmetric(gen,rel) && isReflexive(gen,rel) && isTransitive(gen,rel)
  }.annotate("equivalence")

  def main(argv:Array[String]):Unit = {
    println(existsM("a < 12", LazyList.range(1,20)){ (a:Int) => HeavyBool(a < 12)})
    println(isSymmetric(LazyList.range(1,20), (a:Int, b:Int) => a < b))
    println(isEquivalence(LazyList.range(1,20), (a:Int, b:Int) => a < b))
  }
}
