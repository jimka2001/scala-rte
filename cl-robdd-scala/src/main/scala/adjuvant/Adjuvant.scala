// Copyright (c) 2021 EPITA Research and Development Laboratory
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


package adjuvant

import scala.annotation.tailrec

object Adjuvant {
  def conj[T](seq: Seq[T], obj: T): Seq[T] = seq match {
    // inspired by the Clojure conj function
    // See https://clojuredocs.org/clojure.core/conj
    // given an object and a sequence, add the element to the sequence
    // either at the beginning or end, depending on the type of Seq.
    // It is easier to add to the begging of a list, but to the end of a vector.
    // The caller calls this function when it is not important whether the
    // new element be added to the beginning or the end.
    case Seq() => Seq(obj)
    case l: List[T] => obj :: l
    case _ => seq :+ obj
  }

  def traceGraph[V, L](v0: V, edges: V => Seq[(L, V)]): (Vector[V], Vector[Seq[(L, Int)]]) = {
    val s0: Seq[(L, Int)] = Seq()
    // The local function, recur, traverses the graph generated by the function, edges.
    // The traversal is in numerical order.  The initial vertex is 0, the next
    // vertex generated is 1.  Once the edges of vertex 0 are generated, several
    // vertices may have been generated, but vertex 1 is traversed next, then
    // 2, 3, ...
    // The variable, nextAvailable, keeps track of the next available
    //    vertex number.  When the edges function returns a new v which
    //    has not yet been numbered, then it gets assigned nextAvailable.
    // nextAvailable gets incremented (via recursion) whenever a new vertex
    //    is encountered, and associated with the current value of nextAvailable.
    // The recursion terminates when the index of v is == to nextAvailable
    //    because that means no new vertices have been encountered, thus
    //    all vertices have been visited.
    @tailrec
    def recur(v: V,
              currentStateId:Int,
              nextAvailableState: Int,
              es: List[(L, V)],
              intToV: Vector[V],
              vToInt: Map[V, Int],
              m: Vector[Seq[(L, Int)]]): (Vector[V], Vector[Seq[(L, Int)]]) = {

      es match {
        case (_, v1) :: _ if !vToInt.contains(v1) =>
          // if we are seeing v1 for the first time, then register it
          //   in intToV and in vToInt.
          recur(v, currentStateId, nextAvailableState + 1, es,
                intToV.appended(v1), vToInt + (v1 -> nextAvailableState), m)
        case (label, v1) :: lvs =>
          recur(v, currentStateId, nextAvailableState, lvs, intToV, vToInt,
                m.updated(currentStateId, conj(m(currentStateId), label -> vToInt(v1))))
        case Nil =>
          val next = currentStateId+1
          // The termination condition occurs if next == nextAvailable, because
          //   this means now new vertices have been encountered which have not
          //   yet been treated.
          if (next < nextAvailableState) {
            val v2 = intToV(next)
            recur(v2, next, nextAvailableState, edges(v2).toList, intToV, vToInt, m.appended(s0))
          }
          else
            (intToV, m)
      }
    }

    recur(v0, 0, 1, edges(v0).toList, Vector(v0), Map(v0 -> 0), Vector(s0))

  }

  def searchReplace[A](xs: Seq[A], search: A, replace: A): Seq[A] = {
    xs.map(x => if (search == x) replace else x)
  }

  def findAdjacent[A](xs: Seq[A], cmp: (A, A) => Boolean): Boolean =
    xs.toList.tails.exists {
      case Nil => false
      case _ :: Nil => false
      case x1 :: x2 :: _ => cmp(x1, x2)
    }

  def removeAdjacent[A](xs: Seq[A], cmp: (A, A) => Boolean): Seq[A] =
    xs.toList.tails.flatMap {
      case Nil => Nil
      case x :: Nil => List(x)
      case x1 :: x2 :: _ if cmp(x1, x2) => Nil
      case x :: _ => List(x)
    }.toSeq

  def fixedPoint[V](value: V, f: V => V, cmp: (V, V) => Boolean): V = {
    @tailrec
    def recur(value: V): V = {
      //println("[ fixedPoint: starting with " + value)
      val newValue = f(value)
      //println("] fixedPoint: computed "+ newValue)
      if (cmp(value, newValue))
        value
      else
        recur(newValue)
    }

    recur(value)
  }

  // The memoize method is inspired by
  //  https://clojuredocs.org/clojure.core/memoize
  // Returning a memoized version of a referentially transparent function. The
  // memoized version of the function keeps a cache of the mapping from arguments
  // to results and, when calls with the same arguments are repeated often, has
  // higher performance at the expense of higher memory use.
  def memoize[F, T](f: F => T): F => T = {
    val hash = scala.collection.mutable.Map[F, T]()

    def mem(i: F): T = {
      hash.getOrElse(i, locally {
        val v: T = f(i)
        hash(i) = v
        v
      })
    }

    mem
  }

  def partitionBy[S, T](domain: Set[S], f: S => T): Set[Set[S]] = {
    if (domain.size == 1)
      Set(domain)
    else
      domain.groupBy(f).values.toSet
  }

  @tailrec
  def findSimplifier[T](target: T, simplifiers: List[() => T]): T = {
    // simplifiers is a list of 0-ary functions.   calling such a function
    //   either returns `target` or something else.   we call all the functions
    //   in turn, as long as they return `target`.  As soon as such a function
    //   returns something other than `target`, then that new value is returned
    //   from findSimplifier.  As a last resort, `target` is returned.
    simplifiers match {
      case Nil => target
      case s :: ss =>
        val t2 = s()
        if (target == t2)
          findSimplifier(target, ss)
        else
          t2
    }
  }

  def trace[A](a: A): A = {
    trace("",a)
  }
  def trace[A](msg:String,a:A):A = {
    println(s"$msg: $a")
    a
  }
}
