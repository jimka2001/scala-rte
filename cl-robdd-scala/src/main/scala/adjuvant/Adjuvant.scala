// Copyright (c) 2021 EPITA Research and Development Laboratory
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


package adjuvant

import scala.annotation.tailrec
import scala.collection.mutable

object Adjuvant {
  // inspired by the Clojure conj function
  // See https://clojuredocs.org/clojure.core/conj
  // given an object and a sequence, add the element to the sequence
  // either at the beginning or end, depending on the type of Seq.
  // It is easier to add to the begging of a list, but to the end of a vector.
  // The caller calls this function when it is not important whether the
  // new element be added to the beginning or the end.
  def conj[T](it:Iterable[T],obj:T):Iterable[T] = {
    if(it.isEmpty)
      it ++ Seq(obj)
    else {
      val (singleton,_) = it.splitAt(1)
      it ++ singleton.map(_=>obj)
    }
  }
  // inspired by the Clojure conj function
  // See https://clojuredocs.org/clojure.core/conj
  // given an object and a sequence, add the element to the sequence
  // either at the beginning or end, depending on the type of Seq.
  // It is easier to add to the begging of a list, but to the end of a vector.
  // The caller calls this function when it is not important whether the
  // new element be added to the beginning or the end.
  def conj[T](seq: Seq[T], obj: T): Seq[T] = seq match {
    case Seq() => Seq(obj)
    case l: List[T] => obj :: l
    case _ => seq :+ obj
  }

  def traceGraph[V, L](v0: V, edges: V => Seq[(L, V)]): (Vector[V], Vector[Seq[(L, Int)]]) = {
    val s0: Seq[(L, Int)] = Seq()
    // The local function, recur, traverses the graph generated by the function, edges.
    // The traversal is in numerical order.  The initial vertex is 0, the next
    // vertex generated is 1.  Once the edges of vertex 0 are generated, several
    // vertices may have been generated, but vertex 1 is traversed next, then
    // 2, 3, ...
    // The variable, nextAvailable, keeps track of the next available
    //    vertex number.  When the edges function returns a new v which
    //    has not yet been numbered, then it gets assigned nextAvailable.
    // nextAvailable gets incremented (via recursion) whenever a new vertex
    //    is encountered, and associated with the current value of nextAvailable.
    // The recursion terminates when the index of v is == to nextAvailable
    //    because that means no new vertices have been encountered, thus
    //    all vertices have been visited.
    @tailrec
    def recur(currentStateId:Int,
              nextAvailableState: Int,
              es: List[(L, V)],
              intToV: Vector[V],
              vToInt: Map[V, Int],
              m: Vector[Seq[(L, Int)]]): (Vector[V], Vector[Seq[(L, Int)]]) = {

      es match {
        case (_, v1) :: _ if !vToInt.contains(v1) =>
          // if we are seeing v1 for the first time, then register it
          //   in intToV and in vToInt.
          recur(currentStateId, nextAvailableState + 1, es,
                intToV.appended(v1), vToInt + (v1 -> nextAvailableState), m)
        case (label, v1) :: lvs =>
          recur(currentStateId, nextAvailableState, lvs, intToV, vToInt,
                m.updated(currentStateId, conj(m(currentStateId), label -> vToInt(v1))))
        case Nil =>
          val next = currentStateId+1
          // The termination condition occurs if next == nextAvailable, because
          //   this means now new vertices have been encountered which have not
          //   yet been treated.
          if (next < nextAvailableState) {
            val v2 = intToV(next)
            recur(next, nextAvailableState, edges(v2).toList, intToV, vToInt, m.appended(s0))
          }
          else
            (intToV, m)
      }
    }

    recur(0, 1, edges(v0).toList, Vector(v0), Map(v0 -> 0), Vector(s0))
  }

  // find and replace all occurrences of `search` in the given sequence,
  //   and replace them by splicing with the elements of `replace`
  def searchReplace[A](xs: Seq[A], search: A, replace: Seq[A]): Seq[A] = {
    xs.flatMap(x => if (search == x) replace else Seq(x))
  }

  // find and replace all occurrences of `search` in the given sequence,
  //   and replace them with the element `replace`
  def searchReplace[A](seq:Seq[A],search:A,replace:A):Seq[A] = {
    searchReplace(seq,search,Seq(replace))
  }

  def findAdjacent[A](xs: Seq[A], cmp: (A, A) => Boolean): Boolean =
    xs.toList.tails.exists {
      case Nil => false
      case _ :: Nil => false
      case x1 :: x2 :: _ => cmp(x1, x2)
    }

  // Make a copy of a sequence but removing adjacent duplicates,
  //   which the given function, cmp, is used to determine whether
  //   elements are considered duplicates.
  def removeAdjacent[A](xs: Seq[A], cmp: (A, A) => Boolean): Seq[A] =
    xs.toList.tails.flatMap {
      case Nil => Nil
      case x :: Nil => List(x)
      case x1 :: x2 :: _ if cmp(x1, x2) => Nil
      case x :: _ => List(x)
    }.toSeq

  def fixedPoint[V](seed: V, f: V => V, cmp: (V, V) => Boolean): V = {
    fixedPoint(seed,f,cmp,(_:V) => true)
  }

  def fixedPoint[V](seed: V, f: V => V, cmp: (V, V) => Boolean, invariant: V=>Boolean): V = {
    assert(invariant(seed),s"invariant failed on initial value seed=$seed")
    @tailrec
    def recur(value: V,history:Seq[V],h2:Set[V]): V = {
      val newValue = f(value)
      assert(invariant(newValue), s"invariant failed on computed value=$newValue")
      if (cmp(value, newValue))
        value
      else if( h2.contains(newValue)) {
        val loop = (history++Seq(newValue)).dropWhile( _ != newValue).mkString("\n  ","\n  ","")
        throw new Exception(s"fixedPoint encountered a loop \n    seed=$seed\n    loop=$loop")
      } else
        recur(newValue,history++Seq(value),h2+value)
    }

    recur(seed, Seq(),Set())
  }

  // The memoize method is inspired by
  //  https://clojuredocs.org/clojure.core/memoize
  // Returning a memoized version of a referentially transparent function. The
  // memoized version of the function keeps a cache of the mapping from arguments
  // to results and, when calls with the same arguments are repeated often, has
  // better performance at the expense of higher memory use.
  def memoize[F, T](f: F => T): F => T = {
    val hash = scala.collection.mutable.Map[F, T]()

    def mem(i: F): T = hash.getOrElseUpdate(i, f(i))

    mem
  }

  def partitionBy[S, T](domain: Set[S], f: S => T): Set[Set[S]] = {
    if (domain.size == 1)
      Set(domain)
    else
      domain.groupBy(f).values.toSet
  }

  def findSimplifierDebug[T](tag: String, target: T, simplifiers: List[(String, () => T)]): T = {
    // DEBUG version of findSimplifier,
    //   diagnostics will be printed logging the progression of simplifications
    println(s"$tag: starting with $target")
    val s = findSimplifier(tag, target, verbose = true, simplifiers)
    if (s == target)
      println(s"$tag: remained $s")
    else {
      println(s"$tag:")
      println(s"  changed $target")
      println(s"       to $s")
    }
    s
  }

  val simplifierUsed:mutable.Map[(String,String),Int] = mutable.Map()

  // simplifiers *designates* a list of 0-ary functions.   Calling such a function
  //   either returns `target` or something else.   We call all the functions
  //   in turn, as long as each returns `target`.  As soon as such a function
  //   returns something other than `target`, then that new value is returned
  //   from findSimplifier.  As a last resort, `target` is returned.
  // simplifiers is actually a list of pairs (comment,function).  The function's
  //   implement the semantics, which the comment's are used for debugging.
  //   If verbose=true, then diagnostic messages will be printed to attempt
  //   to help the user understand which of the functions is the one which
  //   successfully simplifies the value.
  @tailrec
  def findSimplifier[T](tag:String, target: T, verbose:Boolean, simplifiers: List[(String, () => T)]): T = {

    simplifiers match {
      case Nil => target
      case (comment, s) :: ss =>
        val t2 = s()
        if (target == t2) {
          // Pass target to recursive call, not t2.
          // The hope is that t2 is newly allocated data
          // and target is older.  Hoping that, holding on to older data
          // and allowing new data to be released is better for the GC.
          findSimplifier(tag = tag, target, verbose=verbose, ss)
        } else {
          if (verbose) {
            println(s"$tag: starting with  $target")
            println(s"    $tag: $comment")
            println(s"    $tag: ----> $t2")
            simplifierUsed.updateWith(tag -> comment) {
              case None => Some(1)
              case Some(a) => Some(a + 1)
            }
          }
          t2
        }
    }
  }

  def sameElementsAnyOrder[A](seq1:Seq[A],seq2:Seq[A]):Boolean = {
    seq1.toSet == seq2.toSet
  }

  // debugging function which prints the given value and returns
  //  the same value.   trace(...) may be wrapped around any
  //  expression without changing the evaluation semantics
  //  of the expression.
  def trace[A](a: A): A = {
    trace("",a)
  }
  // two argument from of trace, which also prints a prefixed
  // message before printing the given value.
  def trace[A](msg:String,a:A):A = {
    println(s"$msg: $a")
    a
  }
  // the standard library method .distinct is not documented
  //   as to whether it preserves order or not.  This function,
  //   uniquify, guarantees order to be preserved.
  //   Duplicates early in the sequence are omitted, preserving
  //   the right-most elements in case duplicates are detected.
  def uniquify[A](seq1:Seq[A]):Seq[A] = {
    @tailrec
    def recurL(seq:List[A], acc:List[A]):List[A] = {
      seq match {
        case Nil => acc.reverse
        case s :: ss if ss.contains(s) => recurL(ss,acc)
        case s :: ss => recurL(ss,s::acc)
      }
    }
    @tailrec
    def recurS(seq:Seq[A], acc:Seq[A]):Seq[A] = {
      seq match {
        case Seq() => acc
        case Seq(s) => acc ++ Seq(s)
        case s =>
          val t = s.tail
          if (t.contains(s.head))
            recurS(t,acc)
          else
            recurS(t,acc ++ Seq(s.head))
      }
    }
    seq1 match {
      case seq:List[A] => recurL(seq,List())
      case seq:Seq[A] => recurS(seq,Seq())
    }
  }
  def openGraphicalFile(fileName:String):String = {
    import sys.process._
    val cmd = Seq("open", "-g", "-a", "Preview", fileName)
    if ("Mac OS X" == System.getProperty("os.name"))
      cmd.!
    else
      sys.error(s"cannot open $fileName because OS = ${System.getProperty("os.name")}")
    fileName
  }

  def makeTmpFileName(prefix:String, suffix:String):String = {
    if (suffix != "" && suffix(0) != '.')
      makeTmpFileName(prefix, "." + suffix)
    else {
      import java.io.File
      File.createTempFile(prefix+"-", suffix).getAbsolutePath
    }
  }

  def copyFile(from:String, to:String):Int = {
    import sys.process._
    Seq("cp", from, to).!
  }

  def filterFile(from:String, to:String, keepIf:String=>Boolean):Unit = {
    import scala.io.Source
    import java.io._
    val w = new BufferedWriter(new FileWriter(to))
    for{ line <- Source.fromFile(from).getLines()
         if keepIf(line)
         } w.write(line + "\n")
    w.close()
  }

  def eql(x:Any, y:Any):Boolean = {
    if (x.getClass != y.getClass)
      false
    else
      (x,y) match {
        case (a:Seq[Any], b:Seq[Any]) => a.size == b.size && a.zip(b).forall{case (a,b) => eql(a,b)}
        case (a,b) => a == b
      }
  }
  def diff(xs:Seq[Any],ys:Seq[Any]):Seq[Any] = {
    // take elements in xs which are not in ys
    xs.filter{x => ! ys.exists(y => eql(x,y))}
  }

  def intersect(xs:Seq[Any],ys:Seq[Any]):Seq[Any] = {
    xs.filter{x => ys.exists(y => eql(x,y))}
  }

  def member(x:Any, ys:Seq[Any]):Boolean = {
    ys.exists{y => eql(x,y)}
  }
}
