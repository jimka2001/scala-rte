// Copyright (c) 2021 EPITA Research and Development Laboratory
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


package adjuvant

import scala.annotation.tailrec
import scala.collection.mutable

object Adjuvant {
  def conj[T](it:Iterable[T],obj:T):Iterable[T] = {
    if(it.isEmpty)
      it ++ Seq(obj)
    else {
      val (singleton,_) = it.splitAt(1)
      it ++ singleton.map(_=>obj)
    }
  }
  def conj[T](seq: Seq[T], obj: T): Seq[T] = seq match {
    // inspired by the Clojure conj function
    // See https://clojuredocs.org/clojure.core/conj
    // given an object and a sequence, add the element to the sequence
    // either at the beginning or end, depending on the type of Seq.
    // It is easier to add to the begging of a list, but to the end of a vector.
    // The caller calls this function when it is not important whether the
    // new element be added to the beginning or the end.
    case Seq() => Seq(obj)
    case l: List[T] => obj :: l
    case _ => seq :+ obj
  }

  def traceGraph[V, L](v0: V, edges: V => Seq[(L, V)]): (Vector[V], Vector[Seq[(L, Int)]]) = {
    val s0: Seq[(L, Int)] = Seq()
    // The local function, recur, traverses the graph generated by the function, edges.
    // The traversal is in numerical order.  The initial vertex is 0, the next
    // vertex generated is 1.  Once the edges of vertex 0 are generated, several
    // vertices may have been generated, but vertex 1 is traversed next, then
    // 2, 3, ...
    // The variable, nextAvailable, keeps track of the next available
    //    vertex number.  When the edges function returns a new v which
    //    has not yet been numbered, then it gets assigned nextAvailable.
    // nextAvailable gets incremented (via recursion) whenever a new vertex
    //    is encountered, and associated with the current value of nextAvailable.
    // The recursion terminates when the index of v is == to nextAvailable
    //    because that means no new vertices have been encountered, thus
    //    all vertices have been visited.
    @tailrec
    def recur(v: V,
              currentStateId:Int,
              nextAvailableState: Int,
              es: List[(L, V)],
              intToV: Vector[V],
              vToInt: Map[V, Int],
              m: Vector[Seq[(L, Int)]]): (Vector[V], Vector[Seq[(L, Int)]]) = {

      es match {
        case (_, v1) :: _ if !vToInt.contains(v1) =>
          // if we are seeing v1 for the first time, then register it
          //   in intToV and in vToInt.
          recur(v, currentStateId, nextAvailableState + 1, es,
                intToV.appended(v1), vToInt + (v1 -> nextAvailableState), m)
        case (label, v1) :: lvs =>
          recur(v, currentStateId, nextAvailableState, lvs, intToV, vToInt,
                m.updated(currentStateId, conj(m(currentStateId), label -> vToInt(v1))))
        case Nil =>
          val next = currentStateId+1
          // The termination condition occurs if next == nextAvailable, because
          //   this means now new vertices have been encountered which have not
          //   yet been treated.
          if (next < nextAvailableState) {
            val v2 = intToV(next)
            recur(v2, next, nextAvailableState, edges(v2).toList, intToV, vToInt, m.appended(s0))
          }
          else
            (intToV, m)
      }
    }

    recur(v0, 0, 1, edges(v0).toList, Vector(v0), Map(v0 -> 0), Vector(s0))

  }
  def searchReplace[A](xs: Seq[A], search: A, replace: Seq[A]): Seq[A] = {
    xs.flatMap(x => if (search == x) replace else Seq(x))
  }
  def searchReplace[A](seq:Seq[A],search:A,replace:A):Seq[A] = {
    searchReplace(seq,search,Seq(replace))
  }

  def findAdjacent[A](xs: Seq[A], cmp: (A, A) => Boolean): Boolean =
    xs.toList.tails.exists {
      case Nil => false
      case _ :: Nil => false
      case x1 :: x2 :: _ => cmp(x1, x2)
    }

  def removeAdjacent[A](xs: Seq[A], cmp: (A, A) => Boolean): Seq[A] =
    xs.toList.tails.flatMap {
      case Nil => Nil
      case x :: Nil => List(x)
      case x1 :: x2 :: _ if cmp(x1, x2) => Nil
      case x :: _ => List(x)
    }.toSeq

  def fixedPoint[V](seed: V, f: V => V, cmp: (V, V) => Boolean): V = {
    @tailrec
    def recur(value: V,history:Seq[V],h2:Set[V]): V = {
      val newValue = f(value)
      if (cmp(value, newValue))
        value
      else if( h2.contains(newValue)) {
        val loop = (history++Seq(newValue)).dropWhile( _ != newValue).mkString("\n  ","\n  ","")
        throw new Exception(s"fixedPoint encountered a loop \n    seed=$seed\n    loop=$loop")
      } else
        recur(newValue,history++Seq(value),h2+value)
    }

    recur(seed, Seq(),Set())
  }

  // The memoize method is inspired by
  //  https://clojuredocs.org/clojure.core/memoize
  // Returning a memoized version of a referentially transparent function. The
  // memoized version of the function keeps a cache of the mapping from arguments
  // to results and, when calls with the same arguments are repeated often, has
  // higher performance at the expense of higher memory use.
  def memoize[F, T](f: F => T): F => T = {
    val hash = scala.collection.mutable.Map[F, T]()

    def mem(i: F): T = {
      hash.getOrElse(i, locally {
        val v: T = f(i)
        hash(i) = v
        v
      })
    }

    mem
  }

  def partitionBy[S, T](domain: Set[S], f: S => T): Set[Set[S]] = {
    if (domain.size == 1)
      Set(domain)
    else
      domain.groupBy(f).values.toSet
  }

  def findSimplifierDebug[T](tag: String, target: T, simplifiers: List[(String, () => T)]): T = {
    // DEBUG version of findSimplifier,  if called with two additional arguments,
    //   diagnostics will be printed logging the progression of simplifications
    println(s"$tag starting with $target")
    val s = findSimplifier(tag, target, verbose = true, simplifiers)
    if (s == target)
      println(s"$tag remained $s")
    else {
      println(s"$tag")
      println(s"  changed $target")
      println(s"       to $s")
    }
    s
  }

  val simplifierUsed:mutable.Map[(String,String),Int] = mutable.Map()

  @tailrec
  def findSimplifier[T](tag:String, target: T, verbose:Boolean, simplifiers: List[(String, () => T)]): T = {
    // simplifiers is a list of 0-ary functions.   calling such a function
    //   either returns `target` or something else.   we call all the functions
    //   in turn, as long as they return `target`.  As soon as such a function
    //   returns something other than `target`, then that new value is returned
    //   from findSimplifier.  As a last resort, `target` is returned.

    simplifiers match {
      case Nil => target
      case (comment, s) :: ss =>
        val t2 = s()
        if (target == t2) {
          // Pass target to recursive call, not t2.
          // The hope is that t2 is newly allocated data
          // and target is older.  Hoping that, holding on to older data
          // and allowing new data to be released is better for the GC.
          findSimplifier(tag = tag, target, verbose=verbose, ss)
        } else {
          if (verbose) {
            println(s"$tag starting with  $target")
            println(s"    $tag $comment")
            println(s"    $tag ----> $t2")
            simplifierUsed.updateWith(tag -> comment) {
              case None => Some(1)
              case Some(a) => Some(a + 1)
            }
          }
          t2
        }
    }
  }

  def sameElementsAnyOrder[A](seq1:Seq[A],seq2:Seq[A]):Boolean = {
    seq1.toSet == seq2.toSet
  }

  def trace[A](a: A): A = {
    trace("",a)
  }
  def trace[A](msg:String,a:A):A = {
    println(s"$msg: $a")
    a
  }
  def uniquify[A](seq1:Seq[A]):Seq[A] = {
    @tailrec
    def recurL(seq:List[A], acc:List[A]):List[A] = {
      seq match {
        case Nil => acc.reverse
        case s :: ss if ss.contains(s) => recurL(ss,acc)
        case s :: ss => recurL(ss,s::acc)
      }
    }
    @tailrec
    def recurS(seq:Seq[A], acc:Seq[A]):Seq[A] = {
      seq match {
        case Seq() => acc
        case Seq(s) => acc ++ Seq(s)
        case s =>
          val t = s.tail
          if (t.contains(s.head))
            recurS(t,acc)
          else
            recurS(t,acc ++ Seq(s.head))
      }
    }
    seq1 match {
      case seq:List[A] => recurL(seq,List())
      case seq:Seq[A] => recurS(seq,Seq())
    }
  }
}
