package rte

import genus.GenusSpecifications.naiveGenGenus
import org.scalacheck.Gen

import scala.util.Random

/*
Implementation of a Boltzmann generator for Rte, according to this paper: https://algo.inria.fr/flajolet/Publications/DuFlLoSc04.pdf
A Boltzmann generator generates in linear time a Rte with size size in [(size - epsilon); (size + epsilon)]
*/
// FIXME: Refactor: And, Or and Cat share the same generator
// FIXME: Refactor: Not and Star share the same generator
class RteBoltzmann(var size: Int) {
  private val x = findGeneratorParameter(size) // The parameter of the generator
  private val oracle = new RteOracle(x)
  private val rand = new RandTools()
  private val stdDepth = 5;

  // Implementation of a generation in ScalaCheck's sense, by using the Boltzmann generation technique
  def RteBoltzmannGen(): Gen[Rte] = Gen.lzy {
    if (rand.Bernouilli(oracle.leaf / (oracle.leaf + oracle.internalnode)))
      genLeaf()
    else
      genInternalNode()
  }

  // Boltzmann generator of the atoms
  def genLeaf(): Gen[Rte] = Gen.lzy {
    val weights = Array(oracle.emptyset, oracle.epsilon, oracle.sigma, oracle.std)
    val gens = Array[Rte](EmptySet, EmptyWord, Sigma, Singleton(naiveGenGenus(stdDepth).sample.get))

    var i = 0
    var found = false
    while (i < weights.length && !found) {
      val rest = for {
        j <- i until weights.length
      } yield weights(j)

      val coef = weights(i) / (weights(i) + rest.sum)
      if (rand.Bernouilli(coef)) {
        found = true
      }
    }

    Gen.const[Rte] (gens(i))
  }

  // Boltzmann generator of the internal nodes
  def genInternalNode(): Gen[Rte] = Gen.lzy {
    val weights = Array(oracle.and, oracle.or, oracle.cat, oracle.star, oracle.not)
    val gens = Array[Gen[Rte]](genAnd(), genOr(), genCat(), genStar(), genNot()) // The lambda form is an attempt to not execute the content of the function. This is not a satisfactory solution, and should be changed in the future

    var i = 0
    var found = false
    while (i < weights.length && !found) {
      val rest = for {
        j <- i until weights.length
      } yield weights(j)

      val coef = weights(i) / (weights(i) + rest.sum)
      if (rand.Bernouilli(coef)) {
        found = true
      }
    }

    Gen.const[Rte] (gens(i).sample.get)
  }

  // Boltzmann generator of the And
  def genAnd(): Gen[Rte] = Gen.lzy {
    val size = rand.Geometric(oracle.rte)
    val args = for {i <- 1 to size} yield RteBoltzmannGen().sample.get

    And(args)
  }

  // Boltzmann generator of the Or
  def genOr(): Gen[Rte] = Gen.lzy {
    val size = rand.Geometric(oracle.rte)
    val args = for {i <- 1 to size} yield RteBoltzmannGen().sample.get

    Or(args)
  }

  // Boltzmann generator of the Cat
  def genCat(): Gen[Rte] = Gen.lzy {
    val size = rand.Geometric(oracle.rte)
    val args = for {i <- 1 to size} yield RteBoltzmannGen().sample.get

    Cat(args)
  }

  // Boltzmann generator of the Not
  def genNot(): Gen[Rte] = Gen.lzy {
    Not(RteBoltzmannGen().sample.get)
  }

  // Boltzmann generator of the Star
  def genStar(): Gen[Rte] = Gen.lzy {
    Star(RteBoltzmannGen().sample.get)
  }

  // Generate a parameter for the Boltzmann generator based on the expected size we want
  def findGeneratorParameter(size: Int): Double = {
    // This value has been generated by the following python script:
    // ```python
    //    from paganini
    //    import *
    //
    //    # -- TO CHANGE
    //    #Insert the expected size of the Rte
    //    size = 25
    //    # -- DO NOT CHANGE ANYTHING PAST THIS COMMENT
    //
    //    sp = Specification()
    //    z
    //    , R = Variable(size)
    //    , Variable()
    //    sp.add(R, z * Seq(R) + z * Seq(R) + z * Seq(R) + z * R + z * R + z + z + z + z)
    //    sp.run_tuner(R)
    //
    //    print(z.value)
    // ```
    // For size 25. If you want to change the expected size, you can use the same script, and change the size variable AND NOTHING ELSE
    // We make us of the paganini (https://github.com/maciej-bendkowski/paganini) python library to tune the parameter
    0.0472331874150073
  }
}

/*
Implementation of an oracle for the Boltzmann generator, according to this paper: https://algo.inria.fr/flajolet/Publications/DuFlLoSc04.pdf
The oracle takes x as the parameter of the Boltzmann generator and precomputes the OGF function for all the components for the generator to be used, with 0 <= x <= ρ, ρ being the radius of convergence of the OGF of Rte.
*/
// FIXME: This class could us some reformating:
//  - All atomes have the same OGF
//  - And, Or and Cat share the same OGF
//  - Not and Star sahre the same OGF
class RteOracle(var x: Double) {
  // OGF for the atoms
  val epsilon = 1
  val emptyset = 1
  val sigma = 1
  val std = 1

  // OGF for the internal nodes
  val and = And(x)
  val or = Or(x)
  val cat = Cat(x)
  val star = Star(x)
  val not = Not(x)

  val leaf = epsilon + emptyset + sigma + std
  val internalnode = and + or + cat + star + not

  val rte = leaf + internalnode

  // OGF for the Rte structure
  // Note: this solution works only if the parameter x is inferior or equal to (12 - sqrt(192))/(-24) ≃ 0.07735026918. This is the condition for the Rte(x) to have solutions in R
  private def Rte(x: Double): Double = {
    val delta = - 12 * Math.pow(x, 2) - 12 * x + 1
    (- (1 + 2 * x) + Math.sqrt(delta)) / (- 2 * (1 + x))
  }

  // OGF for the And structure
  // And is defined by the following algebraic type: and x Seq(Rte)
  private def And(x: Double): Double = {
    1 * (1 / (1 - Rte(x)))
  }

  // OGF for the Or structure
  // Or is defined by the following algebraic type: or x Seq(Rte)
  private def Or(x: Double): Double = {
    1 * (1 / (1 - Rte(x)))
  }

  // OGF for the Cat structure
  // Cat is defined by the following algebraic type: cat x Seq(Rte)
  private def Cat(x: Double): Double = {
    1 * (1 / (1 - Rte(x)))
  }

  // OGF for the Star structure
  // Star is defined by the following algebraic type: star x Rte
  private def Star(x: Double): Double = {
    1 * Rte(x)
  }

  // OGF for the Not structure
  // Not is defined by the following algebraic type: not x Rte
  private def Not(x: Double): Double = {
    1 * Rte(x)
  }
}

/*
  Random generation tools as described in section 5. of : https://algo.inria.fr/flajolet/Publications/DuFlLoSc04.pdf
 */
class RandTools {
  var rand = new Random()

  /**
   * Bernoulli distribution sampler
   * @param p probability of success
   * @return true if success, false if failure
   */
  def Bernouilli(p: Double): Boolean = {
    if (p < 0 || p > 1) throw new IllegalArgumentException(s"RteBoltzmann: Bernouilli: p must be between 0 and 1, but is $p")
    rand.nextDouble() < p
  }

  /**
   * Geometric distribution sampler
   * @param p probability of success
   * @return n with probability p * (1-p)^n
   */
  def Geometric(p: Double): Int = {
    if (p < 0 || p > 1) throw new IllegalArgumentException(s"RteBoltzmann: Geometric: p must be between 0 and 1, but is $p")
    def gen(acc: Int): Int = {
      if (rand.nextDouble() < p)
        acc
      else
        1 + acc
    }
    gen(0)
  }
}
